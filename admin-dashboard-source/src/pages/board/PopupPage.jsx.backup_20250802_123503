import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { Box, Paper, Typography, Dialog, DialogTitle, DialogContent, DialogActions, Button, TextField, FormControl, InputLabel, Select, MenuItem, Grid, FormControlLabel, Switch, Snackbar, Alert, Divider, LinearProgress, IconButton, Card, CardMedia } from '@mui/material';
import { CloudUpload as CloudUploadIcon, Delete as DeleteIcon, InsertPhoto as InsertPhotoIcon } from '@mui/icons-material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { ko } from 'date-fns/locale';
import { 
  TableFilterAndPagination, 
  TableHeader, 
  BaseTable, 
  TableHeightSetting, 
  TableResizeHandle, 
  ColumnVisibilityDialog, 
  PageHeader, 
  PageContainer,
  TableDebugInfo 
} from '../../components/baseTemplate/components';
import { 
  useTableFilterAndPagination, 
  useTableHeader, 
  useTableColumnDrag,
  useTableData,
  useTableHeaderFixed,
  useTableAutoHeight,
  useTableResize,
  useColumnVisibility,
  useTable
} from '../../components/baseTemplate/hooks';
import { 
  popupColumns, 
  popupTypeOptions, 
  popupStatusOptions, 
  popupTargetOptions
} from './data/popupData';
import SimpleRichTextEditor from '../../components/common/SimpleRichTextEditor';
import apiService from '../../services/api';

/**
 * íŒì—… ì„¤ì • í˜ì´ì§€
 */
const PopupPage = () => {
  // íŒì—… ë°ì´í„° ìƒíƒœ
  const [popups, setPopups] = useState([]);
  const [selectedPopup, setSelectedPopup] = useState(null);
  
  // ë‹¤ì´ì–¼ë¡œê·¸ ìƒíƒœ
  const [isDetailDialogOpen, setIsDetailDialogOpen] = useState(false);
  const [isFormDialogOpen, setIsFormDialogOpen] = useState(false);
  const [formMode, setFormMode] = useState('create'); // create or edit
  
  // í¼ ë°ì´í„° ìƒíƒœ
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    popupType: 'notice',
    status: 'active',
    topPosition: 50,
    leftPosition: 50,
    target: 'all',
    width: 400,
    height: 300,
    startDate: new Date(),
    endDate: new Date(),
    closeOnClick: false,
    showOnce: false,
    imageUrl: '',
    linkUrl: '',
    writer: 'ê´€ë¦¬ì'
  });

  // ì•Œë¦¼ ìƒíƒœ
  const [notification, setNotification] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  // ë¡œë”© ìƒíƒœ
  const [loading, setLoading] = useState(false);
  
  // ì´ë¯¸ì§€ ì—…ë¡œë“œ ìƒíƒœ
  const [uploadProgress, setUploadProgress] = useState(0);
  const [isUploading, setIsUploading] = useState(false);
  const [previewImage, setPreviewImage] = useState(null);
  const fileInputRef = useRef(null);

  // ìë™ ë‹«ê¸° ì‹œê°„ ì„¤ì • ìƒíƒœ
  const [autoCloseSettings, setAutoCloseSettings] = useState({
    closeAfterHours: 24,
    enabled: true
  });
  const [autoCloseLoading, setAutoCloseLoading] = useState(false);

  // íŒì—… ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  const fetchPopups = useCallback(async () => {
    setLoading(true);
    try {
      const response = await apiService.popups.getAll();
      if (response.data.success) {
        // ë°±ì—”ë“œ í•„ë“œëª…ì„ í”„ë¡ íŠ¸ì—”ë“œ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        const transformedData = response.data.data.map((popup, index) => ({
          id: popup.id,
          no: index + 1, // ìˆœì°¨ ë²ˆí˜¸
          title: popup.title,
          content: popup.content,
          popupType: popup.popup_type, // popup_type -> popupType
          status: popup.is_active ? 'active' : 'inactive', // is_active -> status
          topPosition: popup.top_position ? parseInt(popup.top_position) : 50,
          leftPosition: popup.left_position ? parseInt(popup.left_position) : 50,
          target: popup.target_type || 'all', // target_type -> target
          width: parseInt(popup.width) || 400,
          height: parseInt(popup.height) || 300,
          startDate: popup.start_date,
          endDate: popup.end_date,
          viewCount: popup.view_count || 0,
          clickCount: popup.click_count || 0,
          closeOnClick: !popup.close_button, // close_button ì—­ì „ ë¡œì§
          showOnce: popup.show_once,
          imageUrl: popup.image_url || '',
          linkUrl: popup.click_url || '',
          writer: popup.writer || popup.created_by_username || 'ê´€ë¦¬ì',
          createdAt: popup.created_at ? popup.created_at.split('T')[0] : '',
          updatedAt: popup.updated_at ? popup.updated_at.split('T')[0] : ''
        }));
        
        setPopups(transformedData);
      }
    } catch (error) {
      console.error('íŒì—… ë¡œë“œ ì‹¤íŒ¨:', error);
      showNotification('íŒì—…ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
    } finally {
      setLoading(false);
    }
  }, []);

  // ìë™ ë‹«ê¸° ì„¤ì • ê°€ì ¸ì˜¤ê¸°
  const fetchAutoCloseSettings = useCallback(async () => {
    try {
      const response = await apiService.popups.getAutoCloseSettings();
      if (response.data.success) {
        setAutoCloseSettings({
          closeAfterHours: response.data.data.close_after_hours || 24,
          enabled: response.data.data.enabled !== false
        });
      }
    } catch (error) {
      console.error('ìë™ ë‹«ê¸° ì„¤ì • ë¡œë“œ ì‹¤íŒ¨:', error);
      // ì—ëŸ¬ ì‹œ ê¸°ë³¸ê°’ ì‚¬ìš©
    }
  }, []);

  // í˜ì´ì§€ ë¡œë“œì‹œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  useEffect(() => {
    fetchPopups();
    fetchAutoCloseSettings();
  }, [fetchPopups, fetchAutoCloseSettings]);

  // ì•Œë¦¼ í‘œì‹œ í•¨ìˆ˜
  const showNotification = (message, severity = 'success') => {
    setNotification({
      open: true,
      message,
      severity
    });
  };

  // ì•Œë¦¼ ë‹«ê¸° í•¨ìˆ˜
  const closeNotification = () => {
    setNotification(prev => ({ ...prev, open: false }));
  };

  // í…Œì´ë¸” ë†’ì´ ìë™ ì¡°ì • - useTableAutoHeight í›… ì‚¬ìš©
  const {
    containerRef,
    tableHeight,
    autoHeight,
    toggleAutoHeight,
    setManualHeight
  } = useTableAutoHeight({
    defaultHeight: '500px',
    defaultAutoHeight: true,
    minHeight: 300,
    bottomMargin: 100
  });

  // í…Œì´ë¸” ë¦¬ì‚¬ì´ì¦ˆ ê¸°ëŠ¥ - useTableResize í›… ì‚¬ìš©
  const {
    isDragging,
    getResizeHandleProps,
    calculateMaxHeight
  } = useTableResize({
    minHeight: 200,
    maxHeight: null,
    useViewportLimit: true,
    viewportMargin: 50,
    onResize: (newHeight) => {
      if (autoHeight) {
        toggleAutoHeight(false);
      }
      setManualHeight(`${newHeight}px`);
    }
  });
  
  // í—¤ë” í–‰ ê³ ì • ê¸°ëŠ¥ - useTableHeaderFixed í›… ì‚¬ìš©
  const {
    tableHeaderRef,
    getTableHeaderStyles
  } = useTableHeaderFixed({
    zIndex: 10,
    boxShadow: '0 2px 5px rgba(0, 0, 0, 0.1)'
  });

  // ì—‘ì…€ ë‹¤ìš´ë¡œë“œ í•¸ë“¤ëŸ¬
  const handleExcelDownload = useCallback(() => {
    console.log('íŒì—… ì—‘ì…€ ë‹¤ìš´ë¡œë“œ');
    showNotification('íŒì—…ì„ ì—‘ì…€ë¡œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.', 'info');
  }, []);

  // ì¸ì‡„ í•¸ë“¤ëŸ¬
  const handlePrint = useCallback(() => {
    console.log('íŒì—… ì¸ì‡„');
    showNotification('íŒì—…ì„ ì¸ì‡„í•©ë‹ˆë‹¤.', 'info');
  }, []);

  // í˜ì´ì§€ë„¤ì´ì…˜ ìƒíƒœ
  const [currentPage, setCurrentPage] = useState(0);
  const [currentRowsPerPage, setCurrentRowsPerPage] = useState(10);

  // useTable í›… ì‚¬ìš© (ì²´í¬ë°•ìŠ¤ ê´€ë ¨ ê¸°ëŠ¥)
  const {
    checkedItems: tableCheckedItems,
    sortConfig: tableSortConfig,
    expandedRows: tableExpandedRows,
    allChecked: tableAllChecked,
    handleSort: tableHandleSort,
    handleCheck: tableHandleCheck,
    handleToggleAll: tableHandleToggleAll,
    handleToggleExpand: tableHandleToggleExpand
  } = useTable({
    data: popups,
    initialSort: { key: null, direction: 'asc' },
    initialCheckedItems: {},
    initialExpandedRows: {},
    indentMode: false,
    page: currentPage,
    rowsPerPage: currentRowsPerPage
  });

  // í–‰ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleRowClick = useCallback((row) => {
    setSelectedPopup(row);
    setIsDetailDialogOpen(true);
  }, []);

  // ì•¡ì…˜ í•¸ë“¤ëŸ¬
  const handleEdit = useCallback((popup) => {
    setSelectedPopup(popup);
    setFormMode('edit');
    setFormData({
      title: popup.title,
      content: popup.content,
      popupType: popup.popupType,
      status: popup.status,
      topPosition: popup.topPosition,
      leftPosition: popup.leftPosition,
      target: popup.target,
      width: popup.width,
      height: popup.height,
      startDate: popup.startDate ? new Date(popup.startDate) : new Date(),
      endDate: popup.endDate ? new Date(popup.endDate) : new Date(),
      closeOnClick: popup.closeOnClick,
      showOnce: popup.showOnce,
      imageUrl: popup.imageUrl || '',
      linkUrl: popup.linkUrl || '',
      writer: popup.writer
    });
    setPreviewImage(popup.imageUrl || null);
    setIsFormDialogOpen(true);
  }, []);

  const handleDelete = useCallback(async (popup) => {
    if (window.confirm(`"${popup.title}" íŒì—…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
      try {
        setLoading(true);
        const response = await apiService.popups.delete(popup.id);
        
        if (response.data.success) {
          showNotification('íŒì—…ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
          // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
          await fetchPopups();
        } else {
          throw new Error(response.data.message || 'íŒì—… ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }
      } catch (error) {
        console.error('íŒì—… ì‚­ì œ ì‹¤íŒ¨:', error);
        const errorMessage = error.response?.data?.message || error.message || 'íŒì—… ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
        showNotification(errorMessage, 'error');
      } finally {
        setLoading(false);
      }
    }
  }, []);

  // ë²„íŠ¼ ì•¡ì…˜ì´ í¬í•¨ëœ ì»¬ëŸ¼ ì„¤ì •
  const columnsWithActions = useMemo(() => {
    return popupColumns.map(column => {
      if (column.id === 'actions') {
        return {
          ...column,
          renderCell: (params) => (
            <Box sx={{ display: 'flex', gap: 1 }}>
              <Button
                size="small"
                onClick={(e) => {
                  e.stopPropagation();
                  handleEdit(params.row);
                }}
              >
                ìˆ˜ì •
              </Button>
              <Button
                size="small"
                color="error"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDelete(params.row);
                }}
              >
                ì‚­ì œ
              </Button>
            </Box>
          )
        };
      }
      return column;
    });
  }, [handleEdit, handleDelete]);

  // ë™ì  í•„í„° ì˜µì…˜ ìƒì„±
  const dynamicFilterOptions = useMemo(() => {
    return [
      {
        id: 'popupType',
        label: 'íŒì—… íƒ€ì…',
        items: [
          { value: '', label: 'ì „ì²´' },
          ...popupTypeOptions
        ]
      },
      {
        id: 'status',
        label: 'ìƒíƒœ',
        items: [
          { value: '', label: 'ì „ì²´' },
          ...popupStatusOptions
        ]
      },
      {
        id: 'target',
        label: 'ëŒ€ìƒ',
        items: [
          { value: '', label: 'ì „ì²´' },
          ...popupTargetOptions
        ]
      }
    ];
  }, []);

  // useTableFilterAndPagination í›… ì‚¬ìš©
  const {
    // í•„í„° ê´€ë ¨ ìƒíƒœ ë° í•¸ë“¤ëŸ¬
    activeFilters,
    handleFilterChange,
    isDateFilterActive,
    handleOpenDateFilter,
    resetDateFilter,
    dateRange,
    
    // í˜ì´ì§€ë„¤ì´ì…˜ ê´€ë ¨ ìƒíƒœ ë° í•¸ë“¤ëŸ¬
    page,
    rowsPerPage,
    totalCount,
    totalPages,
    handlePageChange,
    handleRowsPerPageChange,
    filteredData,
    displayData,
    filterValues,
    handleFilter,
    handleClearFilters
  } = useTableFilterAndPagination({
    columns: columnsWithActions,
    data: popups,
    defaultRowsPerPage: 10,
    hierarchical: false,
    filterOptions: {
      initialFilters: { popupType: '', status: '', target: '' }
    },
    paginationOptions: {
      initialPage: 0,
      initialRowsPerPage: 10,
      totalItems: popups.length,
      onExcelDownload: handleExcelDownload,
      onPrint: handlePrint
    }
  });

  // TableHeader í›… ì‚¬ìš©
  const {
    searchText,
    totalItems,
    sequentialPageNumbers,
    hasPinnedColumns,
    isGridReady,
    handleSearchChange,
    handleClearSearch,
    togglePageNumberMode,
    toggleColumnPin: headerToggleColumnPin,
    setGridReady
  } = useTableHeader({
    initialTotalItems: popups.length,
    initialSequentialPageNumbers: true,
    onSearch: (value) => {
      console.log(`íŒì—… ê²€ìƒ‰: ${value}`);
      if (page !== 0) {
        handlePageChange(0);
      }
    },
    onToggleColumnPin: (hasPinned) => {
      console.log(`ì»¬ëŸ¼ ê³ ì • í† ê¸€: ${hasPinned}`);
      if (hasPinned) {
        setDefaultPinnedColumns();
      } else {
        clearAllPinnedColumns();
      }
    }
  });

  // ê·¸ë¦¬ë“œ ì¤€ë¹„ ìƒíƒœë¡œ ì„¤ì •
  useEffect(() => {
    setGridReady(true);
  }, [setGridReady]);

  // ì»¬ëŸ¼ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê´€ë ¨ í›… ì‚¬ìš©
  const {
    columns,
    dragInfo,
    pinnedColumns,
    handleDragStart,
    handleDragEnd,
    handleDragOver,
    handleDrop,
    updateColumns,
    isColumnPinned,
    toggleColumnPin,
    clearAllPinnedColumns,
    setDefaultPinnedColumns
  } = useTableColumnDrag({
    initialColumns: columnsWithActions,
    tableId: 'popup_table',
    initialPinnedColumns: ['no', 'title'],
    onColumnOrderChange: (newColumns) => {
      console.log('íŒì—… í…Œì´ë¸” ì»¬ëŸ¼ ìˆœì„œ ë³€ê²½:', newColumns);
    }
  });

  // ì»¬ëŸ¼ í‘œì‹œì˜µì…˜ ê´€ë ¨ í›… ì‚¬ìš©
  const {
    columnVisibility,
    visibleColumns,
    hiddenColumnsCount,
    toggleableColumns,
    toggleColumnVisibility,
    showAllColumns,
    resetToDefault
  } = useColumnVisibility(columns, {
    defaultHiddenColumns: [],
    alwaysVisibleColumns: ['no', 'title'],
    tableId: 'popup_table'
  });

  // í‘œì‹œì˜µì…˜ ë‹¤ì´ì–¼ë¡œê·¸ ìƒíƒœ
  const [displayOptionsAnchor, setDisplayOptionsAnchor] = useState(null);
  const isDisplayOptionsOpen = Boolean(displayOptionsAnchor);

  // í‘œì‹œì˜µì…˜ ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleDisplayOptionsClick = useCallback((anchorElement) => {
    setDisplayOptionsAnchor(anchorElement);
  }, []);

  // í‘œì‹œì˜µì…˜ ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸° í•¸ë“¤ëŸ¬
  const handleDisplayOptionsClose = useCallback(() => {
    setDisplayOptionsAnchor(null);
  }, []);

  // í•„í„° ì½œë°± í•¨ìˆ˜
  const filterCallback = useCallback((result, filterId, filterValue) => {
    switch (filterId) {
      case 'popupType':
        if (filterValue === '' || filterValue === 'all') return result;
        return result.filter(item => item.popupType === filterValue);
        
      case 'status':
        if (filterValue === '' || filterValue === 'all') return result;
        return result.filter(item => item.status === filterValue);
        
      case 'target':
        if (filterValue === '' || filterValue === 'all') return result;
        return result.filter(item => item.target === filterValue);
        
      default:
        return result;
    }
  }, []);
  
  // ì»¤ìŠ¤í…€ handleFilterChange í•¨ìˆ˜
  const manualHandleFilterChange = useCallback((filterId, value) => {
    console.log(`íŒì—… í•„í„° ë³€ê²½: ${filterId} = ${value}`);
    handleFilterChange(filterId, value);
  }, [handleFilterChange]);
  
  // ì•ˆì „í•œ í•„í„° ê°’ ì„¤ì •
  const safeActiveFilters = useMemo(() => {
    const result = { ...activeFilters };
    
    Object.keys(result).forEach(key => {
      if (result[key] === 'all') {
        result[key] = '';
      }
    });
    
    return result;
  }, [activeFilters]);

  // useTableData í›…ì„ ì‚¬ìš©í•˜ì—¬ í•„í„°ë§ëœ ë°ì´í„° ê³„ì‚°
  const computedFilteredData = useTableData({
    data: popups,
    activeFilters: safeActiveFilters,
    searchText,
    isDateFilterActive,
    dateRange,
    filterCallback
  });

  // í•„í„°ë§ëœ ë°ì´í„°ì˜ ID ëª©ë¡ ìƒì„±
  const filteredIds = useMemo(() => {
    return computedFilteredData ? computedFilteredData.map(item => item.id) : [];
  }, [computedFilteredData]);

  // í•„í„°ë§ëœ ë°ì´í„° ì²˜ë¦¬ (ê³„ì¸µ êµ¬ì¡° ì—†ì´ ì¼ë°˜ ë°°ì—´ë¡œ ì²˜ë¦¬)
  const filteredFlatData = useMemo(() => {
    // í•„í„°ê°€ ì ìš©ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ê²€ìƒ‰ì–´ê°€ ì—†ëŠ” ê²½ìš° ëª¨ë“  ë°ì´í„° ë°˜í™˜
    const hasActiveFilters = Object.values(safeActiveFilters).some(value => value && value !== '');
    const hasSearchText = searchText && searchText.trim() !== '';
    
    if (!hasActiveFilters && !hasSearchText) {
      return popups;
    }
    
    // í•„í„°ê°€ ìˆëŠ” ê²½ìš°ì—ë§Œ filteredIdsë¡œ í•„í„°ë§
    if (!popups || !filteredIds || filteredIds.length === 0) {
      return [];
    }
    
    return popups.filter(item => filteredIds.includes(item.id));
  }, [popups, filteredIds, safeActiveFilters, searchText]);

  // í•„í„°ë§ëœ ë°ì´í„° ë° í‘œì‹œ ë°ì´í„° ì €ì¥
  const safeFilteredData = filteredFlatData || [];
  
  // ì‹¤ì œ ì „ì²´ í•­ëª© ìˆ˜ ê³„ì‚° (ì¼ë°˜ ë°°ì—´ì´ë¯€ë¡œ ë‹¨ìˆœ ê¸¸ì´)
  const totalFlattenedItems = safeFilteredData.length;

  // í˜ì´ì§€ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handlePageChangeWithLog = useCallback((event, newPageIndex) => {
    let pageIndex = newPageIndex;
    
    if (typeof event === 'number' && newPageIndex === undefined) {
      pageIndex = event;
    }
    
    console.log(`íŒì—… í˜ì´ì§€ ë³€ê²½: ${currentPage} -> ${pageIndex}`);
    
    if (typeof pageIndex !== 'number') {
      console.error('ìœ íš¨í•˜ì§€ ì•Šì€ í˜ì´ì§€ ë²ˆí˜¸:', pageIndex);
      return;
    }
    
    setCurrentPage(pageIndex);
    handlePageChange(pageIndex);
    
    console.log(`íŒì—… í˜ì´ì§€ ${pageIndex + 1} ë¡œë“œ ì™„ë£Œ`);
  }, [currentPage, handlePageChange]);

  // í˜ì´ì§€ë‹¹ í–‰ ìˆ˜ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleRowsPerPageChangeWithLog = useCallback((event) => {
    if (!event || !event.target || !event.target.value) {
      console.error('íŒì—… í–‰ ìˆ˜ ë³€ê²½ ì´ë²¤íŠ¸ ì˜¤ë¥˜:', event);
      return;
    }
    
    const newRowsPerPage = parseInt(event.target.value, 10);
    console.log(`íŒì—… í˜ì´ì§€ë‹¹ í–‰ ìˆ˜ ë³€ê²½: ${currentRowsPerPage} -> ${newRowsPerPage}`);
    
    setCurrentRowsPerPage(newRowsPerPage);
    setCurrentPage(0);
    
    handleRowsPerPageChange(event);
    
    console.log(`íŒì—… í…Œì´ë¸” ìƒˆ í–‰ ìˆ˜ ${newRowsPerPage}ë¡œ ì—…ë°ì´íŠ¸ ì™„ë£Œ`);
  }, [currentRowsPerPage, handleRowsPerPageChange]);

  // í…Œì´ë¸” ê°•ì œ ë¦¬ë Œë”ë§ì„ ìœ„í•œ í‚¤ ê°’
  const [tableKey, setTableKey] = useState(Date.now());
  
  // í˜ì´ì§€ ë˜ëŠ” í–‰ ìˆ˜ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ í…Œì´ë¸” í‚¤ ì—…ë°ì´íŠ¸
  useEffect(() => {
    setTableKey(Date.now());
    console.log(`íŒì—… í…Œì´ë¸” í‚¤ ì—…ë°ì´íŠ¸: í˜ì´ì§€=${currentPage}, í–‰ìˆ˜=${currentRowsPerPage}`);
  }, [currentPage, currentRowsPerPage]);
  
  // ë“œë˜ê·¸ ì•¤ ë“œë¡­ í™œì„±í™”
  const draggableColumns = true;

  // ë“œë˜ê·¸ ê´€ë ¨ í•¸ë“¤ëŸ¬ ëª¨ìŒ
  const dragHandlers = {
    handleDragStart,
    handleDragEnd,
    handleDragOver,
    handleDrop
  };

  // ë“±ë¡ ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleAddClick = () => {
    setFormMode('create');
    setFormData({
      title: '',
      content: '',
      popupType: 'notice',
      status: 'active',
      topPosition: 50,
      leftPosition: 50,
      target: 'all',
      width: 400,
      height: 300,
      startDate: new Date(),
      endDate: new Date(),
      closeOnClick: false,
      showOnce: false,
      imageUrl: '',
      linkUrl: '',
      writer: 'ê´€ë¦¬ì'
    });
    setPreviewImage(null);
    setIsFormDialogOpen(true);
  };

  // ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleRefreshClick = () => {
    fetchPopups();
    showNotification('ë°ì´í„°ë¥¼ ìƒˆë¡œê³ ì¹¨í–ˆìŠµë‹ˆë‹¤.', 'success');
  };

  // ìƒˆ íŒì—… ë“±ë¡ í•¨ìˆ˜
  const handleCreatePopup = async (formData) => {
    try {
      setLoading(true);
      
      // ë°±ì—”ë“œ ìŠ¤í‚¤ë§ˆì— ë§ê²Œ í•„ë“œëª… ë§¤í•‘
      const apiData = {
        title: formData.title,
        content: formData.content,
        popup_type: formData.popupType, // popupType -> popup_type
        top_position: formData.topPosition,
        left_position: formData.leftPosition,
        width: formData.width.toString() + 'px',
        height: formData.height.toString() + 'px',
        image_url: formData.imageUrl || null,
        target_type: formData.target, // target -> target_type
        start_date: formData.startDate ? formData.startDate.toISOString().split('T')[0] : null,
        end_date: formData.endDate ? formData.endDate.toISOString().split('T')[0] : null,
        show_once: formData.showOnce,
        close_button: !formData.closeOnClick, // ì—­ì „ ë¡œì§ (closeOnClick -> close_button)
        click_url: formData.linkUrl || null,
        is_active: formData.status === 'active', // status -> is_active
        priority: 0
      };

      const response = await apiService.popups.create(apiData);
      
      if (response.data.success) {
        showNotification('ìƒˆ íŒì—…ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
        // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
        await fetchPopups();
      } else {
        throw new Error(response.data.message || 'íŒì—… ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('íŒì—… ë“±ë¡ ì‹¤íŒ¨:', error);
      const errorMessage = error.response?.data?.message || error.message || 'íŒì—… ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      showNotification(errorMessage, 'error');
    } finally {
      setLoading(false);
    }
  };

  // íŒì—… ìˆ˜ì • í•¨ìˆ˜
  const handleUpdatePopup = async (id, formData) => {
    try {
      setLoading(true);
      
      // ë°±ì—”ë“œ ìŠ¤í‚¤ë§ˆì— ë§ê²Œ í•„ë“œëª… ë§¤í•‘
      const apiData = {
        title: formData.title,
        content: formData.content,
        popup_type: formData.popupType,
        top_position: formData.topPosition,
        left_position: formData.leftPosition,
        width: formData.width.toString() + 'px',
        height: formData.height.toString() + 'px',
        image_url: formData.imageUrl || null,
        target_type: formData.target,
        start_date: formData.startDate ? formData.startDate.toISOString().split('T')[0] : null,
        end_date: formData.endDate ? formData.endDate.toISOString().split('T')[0] : null,
        show_once: formData.showOnce,
        close_button: !formData.closeOnClick,
        click_url: formData.linkUrl || null,
        is_active: formData.status === 'active',
        priority: 0
      };

      const response = await apiService.popups.update(id, apiData);
      
      if (response.data.success) {
        showNotification('íŒì—…ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
        // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
        await fetchPopups();
      } else {
        throw new Error(response.data.message || 'íŒì—… ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('íŒì—… ìˆ˜ì • ì‹¤íŒ¨:', error);
      const errorMessage = error.response?.data?.message || error.message || 'íŒì—… ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      showNotification(errorMessage, 'error');
    } finally {
      setLoading(false);
    }
  };

  // í¼ ì œì¶œ í•¸ë“¤ëŸ¬
  const handleFormSubmit = async () => {
    if (formMode === 'create') {
      await handleCreatePopup(formData);
    } else {
      await handleUpdatePopup(selectedPopup.id, formData);
    }
    
    setIsFormDialogOpen(false);
  };

  // í¼ í•„ë“œ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleFormChange = (e) => {
    const { name, value, checked } = e.target;
    let processedValue = value;
    
    // ìˆ«ì ì…ë ¥ í•„ë“œ ì²˜ë¦¬ ë° ìœ íš¨ì„± ê²€ì‚¬
    if (name === 'topPosition' || name === 'leftPosition') {
      processedValue = Math.max(0, parseInt(value) || 0); // ìŒìˆ˜ ë¶ˆí—ˆ
    }
    
    setFormData(prev => ({
      ...prev,
      [name]: name === 'closeOnClick' || name === 'showOnce' ? checked : processedValue
    }));
  };

  // ë‚ ì§œ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleDateChange = (name, value) => {
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  // SimpleRichTextEditor ì½˜í…ì¸  ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleContentChange = useCallback((value) => {
    setFormData(prev => ({
      ...prev,
      content: value
    }));
  }, []);

  // ì´ë¯¸ì§€ íŒŒì¼ ê²€ì¦ í•¨ìˆ˜
  const validateImageFile = (file) => {
    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
    const maxSize = 5 * 1024 * 1024; // 5MB
    
    if (!allowedTypes.includes(file.type)) {
      return {
        valid: false,
        message: 'ì§€ì›ë˜ëŠ” ì´ë¯¸ì§€ í˜•ì‹: JPG, PNG, GIF, WebP'
      };
    }
    
    if (file.size > maxSize) {
      return {
        valid: false,
        message: 'íŒŒì¼ í¬ê¸°ëŠ” 5MB ì´í•˜ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.'
      };
    }
    
    return { valid: true };
  };

  // ì´ë¯¸ì§€ ì—…ë¡œë“œ í•¸ë“¤ëŸ¬
  const handleImageUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    // íŒŒì¼ ê²€ì¦
    const validation = validateImageFile(file);
    if (!validation.valid) {
      showNotification(validation.message, 'error');
      return;
    }
    
    try {
      setIsUploading(true);
      setUploadProgress(0);
      
      // FormData ìƒì„±
      const formData = new FormData();
      formData.append('image', file);
      
      // ì—…ë¡œë“œ API í˜¸ì¶œ (ì§„í–‰ë¥  ì¶”ì  í¬í•¨)
      const response = await apiService.popups.uploadImage(formData);
      
      if (response.data.success) {
        const imageUrl = response.data.data.imageUrl;
        
        // í¼ ë°ì´í„°ì— ì´ë¯¸ì§€ URL ì„¤ì •
        setFormData(prev => ({
          ...prev,
          imageUrl: imageUrl
        }));
        
        // ë¯¸ë¦¬ë³´ê¸° ì´ë¯¸ì§€ ì„¤ì •
        setPreviewImage(imageUrl);
        
        showNotification('ì´ë¯¸ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
      } else {
        throw new Error(response.data.message || 'ì´ë¯¸ì§€ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹¤íŒ¨:', error);
      const errorMessage = error.response?.data?.message || error.message || 'ì´ë¯¸ì§€ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      showNotification(errorMessage, 'error');
    } finally {
      setIsUploading(false);
      setUploadProgress(0);
      // íŒŒì¼ input ì´ˆê¸°í™”
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  // ì´ë¯¸ì§€ ì‚­ì œ í•¸ë“¤ëŸ¬
  const handleImageDelete = () => {
    setFormData(prev => ({
      ...prev,
      imageUrl: ''
    }));
    setPreviewImage(null);
    showNotification('ì´ë¯¸ì§€ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
  };

  // ì—ë””í„°ì— ì´ë¯¸ì§€ ì‚½ì… í•¸ë“¤ëŸ¬
  const handleInsertImageToEditor = () => {
    if (formData.imageUrl) {
      const imageHtml = `<img src="${formData.imageUrl}" alt="ì—…ë¡œë“œëœ ì´ë¯¸ì§€" style="max-width: 100%; height: auto;" />`;
      const currentContent = formData.content || '';
      const newContent = currentContent + imageHtml;
      
      setFormData(prev => ({
        ...prev,
        content: newContent
      }));
      
      showNotification('ì´ë¯¸ì§€ê°€ ì—ë””í„°ì— ì‚½ì…ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
    }
  };

  // ìë™ ë‹«ê¸° ì„¤ì • ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleAutoCloseSettingsChange = (field, value) => {
    setAutoCloseSettings(prev => ({
      ...prev,
      [field]: value
    }));
  };

  // ìë™ ë‹«ê¸° ì„¤ì • ì €ì¥ í•¸ë“¤ëŸ¬
  const handleSaveAutoCloseSettings = async () => {
    try {
      setAutoCloseLoading(true);
      
      const apiData = {
        close_after_hours: autoCloseSettings.closeAfterHours,
        enabled: autoCloseSettings.enabled
      };

      const response = await apiService.popups.updateAutoCloseSettings(apiData);
      
      if (response.data.success) {
        showNotification('ìë™ ë‹«ê¸° ì‹œê°„ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
      } else {
        throw new Error(response.data.message || 'ì„¤ì • ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('ìë™ ë‹«ê¸° ì„¤ì • ì €ì¥ ì‹¤íŒ¨:', error);
      const errorMessage = error.response?.data?.message || error.message || 'ì„¤ì • ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      showNotification(errorMessage, 'error');
    } finally {
      setAutoCloseLoading(false);
    }
  };

  return (
    <PageContainer>
      {/* í˜ì´ì§€ í—¤ë” */}
      <PageHeader
        title="íŒì—… ì„¤ì •"
        onAddClick={handleAddClick}
        onDisplayOptionsClick={handleDisplayOptionsClick}
        showAddButton={true}
        showRefreshButton={true}
        onRefreshClick={handleRefreshClick}
        addButtonText="íŒì—… ë“±ë¡"
        sx={{ mb: 2 }}
      />

      {/* ì»¬ëŸ¼ í‘œì‹œì˜µì…˜ ë‹¤ì´ì–¼ë¡œê·¸ */}
      <ColumnVisibilityDialog
        anchorEl={displayOptionsAnchor}
        open={isDisplayOptionsOpen}
        onClose={handleDisplayOptionsClose}
        toggleableColumns={toggleableColumns}
        columnVisibility={columnVisibility}
        onToggleColumn={toggleColumnVisibility}
        onShowAll={showAllColumns}
        onReset={resetToDefault}
        hiddenColumnsCount={hiddenColumnsCount}
        menuWidth="350px"
      />

      <Paper elevation={1} sx={{ p: 3, borderRadius: 2, mb: 3 }}>
        
        {/* í…Œì´ë¸” í—¤ë” ì»´í¬ë„ŒíŠ¸ */}
        <TableHeader
          title="íŒì—… ëª©ë¡"
          totalItems={totalFlattenedItems}
          countLabel="ì´ ##count##ê°œì˜ íŒì—…"
          sequentialPageNumbers={sequentialPageNumbers}
          togglePageNumberMode={togglePageNumberMode}
          hasPinnedColumns={hasPinnedColumns}
          isGridReady={isGridReady}
          toggleColumnPin={headerToggleColumnPin}
          searchText={searchText}
          handleSearchChange={handleSearchChange}
          handleClearSearch={handleClearSearch}
          showIndentToggle={false}
          showPageNumberToggle={true}
          showColumnPinToggle={true}
          showSearch={true}
          searchPlaceholder="íŒì—… ê²€ìƒ‰..."
          sx={{ mb: 2 }}
        />

        {/* í…Œì´ë¸” ë†’ì´ ì„¤ì • */}
        <TableHeightSetting
          tableHeight={tableHeight}
          autoHeight={autoHeight}
          toggleAutoHeight={toggleAutoHeight}
          setManualHeight={setManualHeight}
          minHeight={200}
          maxHeight={1200}
          step={50}
        />

        <Box sx={{ width: '100%' }}>
          <TableFilterAndPagination
            filterProps={{
              columns: columns,
              filterValues: filterValues || {},
              activeFilters: safeActiveFilters || {},
              filterOptions: dynamicFilterOptions,
              handleFilterChange: manualHandleFilterChange,
              onFilter: handleFilter,
              onClearFilters: handleClearFilters,
              isDateFilterActive: isDateFilterActive,
              handleOpenDateFilter: handleOpenDateFilter,
              resetDateFilter: resetDateFilter
            }}
            paginationProps={{
              count: totalFlattenedItems,
              page: currentPage,
              rowsPerPage: currentRowsPerPage,
              onPageChange: handlePageChangeWithLog,
              onRowsPerPageChange: handleRowsPerPageChangeWithLog,
              totalCount: totalFlattenedItems,
              onExcelDownload: handleExcelDownload,
              onPrint: handlePrint
            }}
          />
        </Box>
        
        {/* í…Œì´ë¸” ì½˜í…ì¸  ì˜ì—­ */}
        <Box 
          sx={{ 
            width: '100%', 
            mt: 2
          }} 
          ref={containerRef}
        >
          <Typography variant="body2" sx={{ mb: 1, color: 'text.secondary' }}>
            í˜„ì¬ í˜ì´ì§€: {currentPage + 1} / {Math.ceil(totalFlattenedItems / currentRowsPerPage)} (í˜ì´ì§€ë‹¹ {currentRowsPerPage}í–‰)
            {' - ì»¬ëŸ¼ì„ ë“œë˜ê·¸í•˜ì—¬ ìˆœì„œë¥¼ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'}
          </Typography>
          <BaseTable
            key={`popup-table-${tableKey}`}
            columns={visibleColumns}
            data={safeFilteredData}
            checkable={true}
            hierarchical={false}
            indentMode={false}
            checkedItems={tableCheckedItems}
            expandedRows={tableExpandedRows}
            allChecked={tableAllChecked}
            onCheck={tableHandleCheck}
            onToggleAll={tableHandleToggleAll}
            onToggleExpand={tableHandleToggleExpand}
            onSort={tableHandleSort}
            sortConfig={tableSortConfig}
            page={currentPage}
            rowsPerPage={currentRowsPerPage}
            totalCount={totalFlattenedItems}
            sequentialPageNumbers={sequentialPageNumbers}
            draggableColumns={draggableColumns}
            onColumnOrderChange={updateColumns}
            dragHandlers={dragHandlers}
            dragInfo={dragInfo}
            fixedHeader={true}
            maxHeight={tableHeight}
            tableHeaderRef={tableHeaderRef}
            headerStyle={getTableHeaderStyles()}
            pinnedColumns={pinnedColumns}
            onRowClick={handleRowClick}
            onEdit={handleEdit}
            onDelete={handleDelete}
            sx={{
              '& table': {
                tableLayout: 'fixed !important',
                width: '100% !important'
              }
            }}
          />

          {/* í…Œì´ë¸” ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ */}
          <TableResizeHandle 
            resizeHandleProps={getResizeHandleProps(parseFloat(tableHeight))}
            showIcon={true}
            isDragging={isDragging}
            sx={{ 
              mt: 1,
              opacity: isDragging ? 1 : 0.7,
              '&:hover': { opacity: 1 }
            }}
          />
        </Box>
      </Paper>

      {/* ìë™ ë‹«ê¸° ì‹œê°„ ì„¤ì • ì„¹ì…˜ */}
      <Paper elevation={1} sx={{ p: 3, borderRadius: 2, mb: 3 }}>
        <Typography variant="h6" sx={{ mb: 2, display: 'flex', alignItems: 'center' }}>
          â° íŒì—… ìë™ ë‹«ê¸° ì‹œê°„ ì„¤ì •
          <Typography variant="body2" sx={{ ml: 2, color: 'text.secondary', fontWeight: 'normal' }}>
            ëª¨ë“  íŒì—…ì— ê³µí†µìœ¼ë¡œ ì ìš©ë˜ëŠ” ì „ì—­ ì„¤ì •ì…ë‹ˆë‹¤
          </Typography>
        </Typography>
        
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 3, flexWrap: 'wrap' }}>
          <FormControlLabel
            control={
              <Switch
                checked={autoCloseSettings.enabled}
                onChange={(e) => handleAutoCloseSettingsChange('enabled', e.target.checked)}
                color="primary"
              />
            }
            label="ìë™ ë‹«ê¸° ê¸°ëŠ¥ í™œì„±í™”"
          />
          
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <TextField
              label="ìë™ ë‹«ê¸° ì‹œê°„"
              type="number"
              value={autoCloseSettings.closeAfterHours}
              onChange={(e) => handleAutoCloseSettingsChange('closeAfterHours', parseInt(e.target.value) || 1)}
              size="small"
              sx={{ width: 120 }}
              disabled={!autoCloseSettings.enabled}
              inputProps={{ 
                min: 1, 
                max: 8760 // 1ë…„ = 365 * 24 ì‹œê°„
              }}
              InputProps={{
                endAdornment: 'ì‹œê°„'
              }}
            />
            <Typography variant="body2" sx={{ color: 'text.secondary', minWidth: 200 }}>
              ({autoCloseSettings.closeAfterHours}ì‹œê°„ = {Math.round(autoCloseSettings.closeAfterHours / 24 * 10) / 10}ì¼)
            </Typography>
          </Box>
          
          <Button
            variant="contained"
            onClick={handleSaveAutoCloseSettings}
            disabled={autoCloseLoading || !autoCloseSettings.enabled}
            size="small"
            sx={{ minWidth: 100 }}
          >
            {autoCloseLoading ? 'ì €ì¥ì¤‘...' : 'ì„¤ì • ì €ì¥'}
          </Button>
        </Box>
        
        <Box sx={{ mt: 2, p: 2, bgcolor: 'background.default', borderRadius: 1 }}>
          <Typography variant="body2" sx={{ color: 'text.secondary', lineHeight: 1.5 }}>
            ğŸ“Œ <strong>ì„¤ì • ì•ˆë‚´:</strong>
            <br />
            â€¢ í™œì„±í™” ì‹œ ì‚¬ìš©ìê°€ "ì˜¤ëŠ˜ í•˜ë£¨ ë™ì•ˆ ë³´ì§€ ì•Šê¸°"ë¥¼ ì„ íƒí•œ íŒì—…ì´ ì„¤ì •ëœ ì‹œê°„ í›„ ë‹¤ì‹œ í‘œì‹œë©ë‹ˆë‹¤
            <br />
            â€¢ ê¸°ë³¸ê°’ì€ 24ì‹œê°„(1ì¼)ì´ë©°, ìµœëŒ€ 8760ì‹œê°„(1ë…„)ê¹Œì§€ ì„¤ì • ê°€ëŠ¥í•©ë‹ˆë‹¤
            <br />
            â€¢ ì´ ì„¤ì •ì€ ëª¨ë“  íŒì—…ì— ê³µí†µìœ¼ë¡œ ì ìš©ë˜ë©°, ê°œë³„ íŒì—…ë³„ ì„¤ì •ì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤
            <br />
            â€¢ ì„¤ì • ë³€ê²½ í›„ ë°˜ë“œì‹œ "ì„¤ì • ì €ì¥" ë²„íŠ¼ì„ í´ë¦­í•´ì£¼ì„¸ìš”
          </Typography>
        </Box>
      </Paper>

      {/* íŒì—… ìƒì„¸ ë‹¤ì´ì–¼ë¡œê·¸ */}
      <Dialog
        open={isDetailDialogOpen}
        onClose={() => setIsDetailDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        {selectedPopup && (
          <>
            <DialogTitle>
              íŒì—… ìƒì„¸ ì •ë³´
            </DialogTitle>
            <DialogContent dividers>
              <Typography variant="h6" gutterBottom>
                {selectedPopup.title}
              </Typography>
              
              <Box sx={{ mb: 2, display: 'flex', justifyContent: 'space-between', color: 'text.secondary' }}>
                <Typography variant="body2">
                  ì‘ì„±ì: {selectedPopup.writer} | 
                  ë“±ë¡ì¼: {selectedPopup.createdAt} | 
                  ìˆ˜ì •ì¼: {selectedPopup.updatedAt}
                </Typography>
                <Typography variant="body2">
                  íƒ€ì…: {
                    popupTypeOptions.find(opt => opt.value === selectedPopup.popupType)?.label
                  } | 
                  ìƒíƒœ: {
                    popupStatusOptions.find(opt => opt.value === selectedPopup.status)?.label
                  }
                </Typography>
              </Box>
              
              <Box sx={{ mb: 2, display: 'flex', justifyContent: 'space-between', color: 'text.secondary' }}>
                <Typography variant="body2">
                  ìœ„ì¹˜: Top {selectedPopup.topPosition}px, Left {selectedPopup.leftPosition}px | 
                  ëŒ€ìƒ: {
                    popupTargetOptions.find(opt => opt.value === selectedPopup.target)?.label
                  }
                </Typography>
                <Typography variant="body2">
                  í¬ê¸°: {selectedPopup.width}x{selectedPopup.height}px | 
                  ì‹œì‘ì¼: {selectedPopup.startDate} | 
                  ì¢…ë£Œì¼: {selectedPopup.endDate}
                </Typography>
              </Box>
              
              <Box sx={{ mb: 2, display: 'flex', justifyContent: 'space-between', color: 'text.secondary' }}>
                <Typography variant="body2">
                  ë…¸ì¶œìˆ˜: {selectedPopup.viewCount?.toLocaleString() || 0}íšŒ | 
                  í´ë¦­ìˆ˜: {selectedPopup.clickCount?.toLocaleString() || 0}íšŒ
                </Typography>
                <Typography variant="body2">
                  í´ë¦­ì‹œ ë‹«ê¸°: {selectedPopup.closeOnClick ? 'ì˜ˆ' : 'ì•„ë‹ˆì˜¤'} | 
                  í•œë²ˆë§Œ í‘œì‹œ: {selectedPopup.showOnce ? 'ì˜ˆ' : 'ì•„ë‹ˆì˜¤'}
                </Typography>
              </Box>
              
              <Divider sx={{ mb: 2 }} />
              
              <Typography variant="body1" component="div" sx={{ whiteSpace: 'pre-wrap' }}>
                {selectedPopup.content}
              </Typography>
              
              {selectedPopup.imageUrl && (
                <Box sx={{ mt: 2 }}>
                  <Typography variant="body2" sx={{ mb: 1, color: 'text.secondary' }}>
                    ì´ë¯¸ì§€ URL: {selectedPopup.imageUrl}
                  </Typography>
                </Box>
              )}
              
              {selectedPopup.linkUrl && (
                <Box sx={{ mt: 1 }}>
                  <Typography variant="body2" sx={{ color: 'text.secondary' }}>
                    ë§í¬ URL: {selectedPopup.linkUrl}
                  </Typography>
                </Box>
              )}
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setIsDetailDialogOpen(false)}>ë‹«ê¸°</Button>
              <Button onClick={() => {
                setIsDetailDialogOpen(false);
                handleEdit(selectedPopup);
              }}>ìˆ˜ì •</Button>
              <Button color="error" onClick={() => {
                setIsDetailDialogOpen(false);
                handleDelete(selectedPopup);
              }}>ì‚­ì œ</Button>
            </DialogActions>
          </>
        )}
      </Dialog>

      {/* íŒì—… ë“±ë¡/ìˆ˜ì • ë‹¤ì´ì–¼ë¡œê·¸ */}
      <Dialog
        open={isFormDialogOpen}
        onClose={() => setIsFormDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {formMode === 'create' ? 'íŒì—… ë“±ë¡' : 'íŒì—… ìˆ˜ì •'}
        </DialogTitle>
        <DialogContent dividers>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                name="title"
                label="íŒì—…ëª…"
                value={formData.title}
                onChange={handleFormChange}
                fullWidth
                margin="normal"
                required
              />
            </Grid>
            
            <Grid item xs={12} md={4}>
              <FormControl fullWidth margin="normal">
                <InputLabel>íŒì—… íƒ€ì…</InputLabel>
                <Select
                  name="popupType"
                  value={formData.popupType}
                  onChange={handleFormChange}
                  label="íŒì—… íƒ€ì…"
                >
                  {popupTypeOptions.map(option => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} md={4}>
              <FormControl fullWidth margin="normal">
                <InputLabel>ìƒíƒœ</InputLabel>
                <Select
                  name="status"
                  value={formData.status}
                  onChange={handleFormChange}
                  label="ìƒíƒœ"
                >
                  {popupStatusOptions.map(option => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} md={2}>
              <TextField
                name="topPosition"
                label="ìœ„ì¹˜ Top"
                type="number"
                value={formData.topPosition}
                onChange={handleFormChange}
                fullWidth
                margin="normal"
                inputProps={{ min: 0 }}
                InputProps={{
                  endAdornment: 'px'
                }}
                helperText="ìƒë‹¨ìœ¼ë¡œë¶€í„° ê±°ë¦¬"
              />
            </Grid>
            
            <Grid item xs={12} md={2}>
              <TextField
                name="leftPosition"
                label="ìœ„ì¹˜ Left"
                type="number"
                value={formData.leftPosition}
                onChange={handleFormChange}
                fullWidth
                margin="normal"
                inputProps={{ min: 0 }}
                InputProps={{
                  endAdornment: 'px'
                }}
                helperText="ì¢Œì¸¡ìœ¼ë¡œë¶€í„° ê±°ë¦¬"
              />
            </Grid>
            
            <Grid item xs={12} md={6}>
              <FormControl fullWidth margin="normal">
                <InputLabel>ëŒ€ìƒ</InputLabel>
                <Select
                  name="target"
                  value={formData.target}
                  onChange={handleFormChange}
                  label="ëŒ€ìƒ"
                >
                  {popupTargetOptions.map(option => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} md={3}>
              <TextField
                name="width"
                label="ê°€ë¡œ í¬ê¸°"
                type="number"
                value={formData.width}
                onChange={handleFormChange}
                fullWidth
                margin="normal"
                InputProps={{
                  endAdornment: 'px'
                }}
              />
            </Grid>
            
            <Grid item xs={12} md={3}>
              <TextField
                name="height"
                label="ì„¸ë¡œ í¬ê¸°"
                type="number"
                value={formData.height}
                onChange={handleFormChange}
                fullWidth
                margin="normal"
                InputProps={{
                  endAdornment: 'px'
                }}
              />
            </Grid>
            
            {/* LocalizationProvider only for date fields */}
            <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ko}>
              <Grid item xs={12} md={6}>
                <DatePicker
                  label="ì‹œì‘ì¼"
                  value={formData.startDate}
                  onChange={(value) => handleDateChange('startDate', value)}
                  renderInput={(params) => <TextField {...params} fullWidth margin="normal" />}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <DatePicker
                  label="ì¢…ë£Œì¼"
                  value={formData.endDate}
                  onChange={(value) => handleDateChange('endDate', value)}
                  renderInput={(params) => <TextField {...params} fullWidth margin="normal" />}
                />
              </Grid>
            </LocalizationProvider>
            
            <Grid item xs={12} md={6}>
              <FormControlLabel
                control={
                  <Switch
                    name="closeOnClick"
                    checked={formData.closeOnClick}
                    onChange={handleFormChange}
                  />
                }
                label="í´ë¦­ì‹œ ë‹«ê¸°"
              />
            </Grid>
            
            <Grid item xs={12} md={6}>
              <FormControlLabel
                control={
                  <Switch
                    name="showOnce"
                    checked={formData.showOnce}
                    onChange={handleFormChange}
                  />
                }
                label="í•œë²ˆë§Œ í‘œì‹œ"
              />
            </Grid>
            
            {/* ì´ë¯¸ì§€ ì—…ë¡œë“œ ì„¹ì…˜ */}
            <Grid item xs={12}>
              <Box sx={{ mb: 2 }}>
                <Typography variant="subtitle2" sx={{ mb: 1, color: 'text.secondary' }}>
                  íŒì—… ì´ë¯¸ì§€
                </Typography>
                
                {/* ì´ë¯¸ì§€ URL ì…ë ¥ í•„ë“œ */}
                <TextField
                  name="imageUrl"
                  label="ì´ë¯¸ì§€ URL (ì§ì ‘ ì…ë ¥)"
                  value={formData.imageUrl}
                  onChange={handleFormChange}
                  fullWidth
                  margin="normal"
                  size="small"
                  helperText="URLì„ ì§ì ‘ ì…ë ¥í•˜ê±°ë‚˜ ì•„ë˜ ì—…ë¡œë“œ ë²„íŠ¼ì„ ì‚¬ìš©í•˜ì„¸ìš”"
                />
                
                {/* íŒŒì¼ ì—…ë¡œë“œ ë²„íŠ¼ */}
                <Box sx={{ display: 'flex', gap: 2, alignItems: 'center', mt: 2, mb: 2 }}>
                  <input
                    type="file"
                    ref={fileInputRef}
                    onChange={handleImageUpload}
                    accept="image/*"
                    style={{ display: 'none' }}
                  />
                  
                  <Button
                    variant="outlined"
                    startIcon={<CloudUploadIcon />}
                    onClick={() => fileInputRef.current?.click()}
                    disabled={isUploading}
                    size="small"
                  >
                    {isUploading ? 'ì—…ë¡œë“œ ì¤‘...' : 'ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ'}
                  </Button>
                  
                  {formData.imageUrl && (
                    <>
                      <Button
                        variant="outlined"
                        startIcon={<InsertPhotoIcon />}
                        onClick={handleInsertImageToEditor}
                        size="small"
                        color="primary"
                      >
                        ì—ë””í„°ì— ì‚½ì…
                      </Button>
                      
                      <IconButton
                        color="error"
                        onClick={handleImageDelete}
                        size="small"
                        title="ì´ë¯¸ì§€ ì‚­ì œ"
                      >
                        <DeleteIcon />
                      </IconButton>
                    </>
                  )}
                </Box>
                
                {/* ì—…ë¡œë“œ ì§„í–‰ë¥  í‘œì‹œ */}
                {isUploading && (
                  <Box sx={{ width: '100%', mb: 2 }}>
                    <LinearProgress 
                      variant="indeterminate" 
                      sx={{ height: 8, borderRadius: 4 }}
                    />
                    <Typography variant="body2" sx={{ mt: 1, color: 'text.secondary' }}>
                      ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ëŠ” ì¤‘ì…ë‹ˆë‹¤...
                    </Typography>
                  </Box>
                )}
                
                {/* ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° */}
                {(previewImage || formData.imageUrl) && (
                  <Card sx={{ maxWidth: 400, mb: 2 }}>
                    <CardMedia
                      component="img"
                      height="200"
                      image={previewImage || formData.imageUrl}
                      alt="ë¯¸ë¦¬ë³´ê¸° ì´ë¯¸ì§€"
                      onError={(e) => {
                        e.target.style.display = 'none';
                        showNotification('ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. URLì„ í™•ì¸í•´ì£¼ì„¸ìš”.', 'warning');
                      }}
                      sx={{
                        objectFit: 'contain',
                        backgroundColor: 'grey.100'
                      }}
                    />
                    <Box sx={{ p: 1, bgcolor: 'grey.50' }}>
                      <Typography variant="caption" sx={{ 
                        color: 'text.secondary',
                        wordBreak: 'break-all',
                        fontSize: '0.7rem'
                      }}>
                        {previewImage || formData.imageUrl}
                      </Typography>
                    </Box>
                  </Card>
                )}
                
                {/* ì—…ë¡œë“œ ì•ˆë‚´ */}
                <Box sx={{ p: 2, bgcolor: 'info.light', borderRadius: 1, mt: 2 }}>
                  <Typography variant="body2" sx={{ color: 'info.contrastText', fontSize: '0.85rem' }}>
                    <strong>ì´ë¯¸ì§€ ì—…ë¡œë“œ ì•ˆë‚´:</strong><br />
                    â€¢ ì§€ì› í˜•ì‹: JPG, PNG, GIF, WebP<br />
                    â€¢ ìµœëŒ€ íŒŒì¼ í¬ê¸°: 5MB<br />
                    â€¢ ì—…ë¡œë“œëœ ì´ë¯¸ì§€ëŠ” ìë™ìœ¼ë¡œ URLì´ ì„¤ì •ë©ë‹ˆë‹¤<br />
                    â€¢ "ì—ë””í„°ì— ì‚½ì…" ë²„íŠ¼ìœ¼ë¡œ íŒì—… ë‚´ìš©ì— ì´ë¯¸ì§€ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
                  </Typography>
                </Box>
              </Box>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                name="linkUrl"
                label="ë§í¬ URL (ì„ íƒì‚¬í•­)"
                value={formData.linkUrl}
                onChange={handleFormChange}
                fullWidth
                margin="normal"
              />
            </Grid>
            
            {/* SimpleRichTextEditor */}
            <Grid item xs={12}>
              <SimpleRichTextEditor
                key="popup-content-editor"
                value={formData.content}
                onChange={handleContentChange}
                label="íŒì—… ë‚´ìš©"
                height={300}
                required
                onImageInsert={handleInsertImageToEditor}
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                name="writer"
                label="ì‘ì„±ì"
                value={formData.writer}
                onChange={handleFormChange}
                fullWidth
                margin="normal"
                required
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setIsFormDialogOpen(false)}>ì·¨ì†Œ</Button>
          <Button 
            variant="contained" 
            onClick={handleFormSubmit}
            disabled={!formData.title || !formData.content || !formData.writer || loading}
          >
            {loading ? 'ì²˜ë¦¬ì¤‘...' : (formMode === 'create' ? 'ë“±ë¡' : 'ìˆ˜ì •')}
          </Button>
        </DialogActions>
      </Dialog>

      {/* ì•Œë¦¼ ìŠ¤ë‚µë°” */}
      <Snackbar
        open={notification.open}
        autoHideDuration={4000}
        onClose={closeNotification}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert 
          onClose={closeNotification} 
          severity={notification.severity} 
          sx={{ width: '100%' }}
        >
          {notification.message}
        </Alert>
      </Snackbar>
    </PageContainer>
  );
};

export default PopupPage;
