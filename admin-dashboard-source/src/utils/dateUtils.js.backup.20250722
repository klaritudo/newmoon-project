/**
 * 날짜 관련 유틸리티 함수들
 */

/**
 * 날짜를 한국 형식으로 포맷팅
 * @param {string|Date} dateValue - 날짜 값 (ISO string with/without 'Z', Date object)
 * @param {boolean} includeTime - 시간 포함 여부 (기본값: true)
 * @returns {string} 포맷된 날짜 문자열
 */
export const formatDateKorean = (dateValue, includeTime = true) => {
  if (!dateValue) return '-';
  
  try {
    let date;
    
    if (typeof dateValue === 'string') {
      // MySQL datetime 형식 (YYYY-MM-DD HH:mm:ss) 체크
      if (dateValue.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/)) {
        // DB에 이미 KST로 저장되어 있으므로 그대로 사용
        const [datePart, timePart] = dateValue.split(' ');
        date = new Date(`${datePart}T${timePart}`); // 로컬 시간으로 파싱
      } 
      // ISO 문자열에 'Z'가 있으면 UTC로 처리
      else if (dateValue.includes('T') && dateValue.includes('Z')) {
        date = new Date(dateValue);
        // Date 객체는 자동으로 로컬 시간대로 변환되므로 추가 변환 불필요
      }
      // 그 외의 경우 그대로 처리
      else {
        date = new Date(dateValue);
      }
    } else {
      date = new Date(dateValue);
    }
    
    // Invalid date check
    if (isNaN(date.getTime())) {
      return '-';
    }
    
    // 수동으로 포맷팅
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    
    if (includeTime) {
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const seconds = String(date.getSeconds()).padStart(2, '0');
      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    } else {
      return `${year}-${month}-${day}`;
    }
  } catch (error) {
    console.error('Date formatting error:', error);
    return '-';
  }
};

/**
 * 날짜를 YYYY-MM-DD 형식으로 포맷팅
 * @param {string|Date} dateValue - 날짜 값
 * @returns {string} YYYY-MM-DD 형식의 날짜 문자열
 */
export const formatDateISO = (dateValue) => {
  if (!dateValue) return '-';
  
  try {
    const date = new Date(dateValue);
    
    if (isNaN(date.getTime())) {
      return '-';
    }
    
    return date.toISOString().split('T')[0];
  } catch (error) {
    console.error('Date formatting error:', error);
    return '-';
  }
};

/**
 * 날짜를 YYYY-MM-DD HH:mm:ss 형식으로 포맷팅
 * @param {string|Date} dateValue - 날짜 값
 * @returns {string} YYYY-MM-DD HH:mm:ss 형식의 날짜 문자열
 */
export const formatDateTime = (dateValue) => {
  if (!dateValue) return '-';
  
  try {
    const date = new Date(dateValue);
    
    if (isNaN(date.getTime())) {
      return '-';
    }
    
    // 수동으로 포맷팅 (로컬 시간대 사용)
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  } catch (error) {
    console.error('Date formatting error:', error);
    return '-';
  }
};

/**
 * 상대적인 시간 표시 (예: 5분 전, 1시간 전)
 * @param {string|Date} dateValue - 날짜 값
 * @returns {string} 상대적인 시간 문자열
 */
export const formatRelativeTime = (dateValue) => {
  if (!dateValue) return '-';
  
  try {
    const date = new Date(dateValue);
    const now = new Date();
    
    if (isNaN(date.getTime())) {
      return '-';
    }
    
    const diffMs = now - date;
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHour = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHour / 24);
    
    if (diffDay > 0) {
      return `${diffDay}일 전`;
    } else if (diffHour > 0) {
      return `${diffHour}시간 전`;
    } else if (diffMin > 0) {
      return `${diffMin}분 전`;
    } else {
      return '방금 전';
    }
  } catch (error) {
    console.error('Relative time formatting error:', error);
    return '-';
  }
};