# 회원 추적 시스템 재분석 보고서 및 구현 계획

## 📊 데이터 영속성(Data Persistence) 개념

**데이터 영속성**이란 프로그램이 종료되거나 시스템이 재시작되어도 데이터가 유지되는 특성을 말합니다.
- **영속성 있음**: 데이터베이스, 파일 시스템에 저장 → 서버 재시작 후에도 데이터 유지
- **영속성 없음**: 메모리(RAM)에만 저장 → 서버 재시작 시 데이터 소실

## 📊 종합 재분석 결과

### 1. 시스템 아키텍처 현황

```
┌─────────────────────────────────────────────────────────┐
│                     Frontend (React)                     │
│  - admin-dashboard-source                                │
│  - Socket.IO Client 구현 완료                            │
│  - ActiveUsersTable 컴포넌트 (하드코딩 데이터)          │
└────────────────┬────────────────────────────────────────┘
                 │ WebSocket (Socket.IO)
┌────────────────┴────────────────────────────────────────┐
│                   Backend (Node.js)                      │
│  - admin-api-source                                      │
│  - UserStatusService (메모리 기반 - 영속성 없음)         │
│  - Socket.IO Server 구현 완료                            │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────┴────────────────────────────────────────┐
│                    Database (MySQL)                      │
│  - members 테이블 (일부 추적 필드 존재)                  │
│  - user_activity_logs (50만+ 레코드, 활발히 사용)       │
│  - login_logs, game_play_logs 등 (사용 중)              │
└─────────────────────────────────────────────────────────┘
```

### 2. 현재 구현 상태 (정확한 재분석)

#### ✅ **구현 완료**
1. **실시간 통신 인프라**
   - Socket.IO 기반 양방향 통신 완전 구현
   - JWT 토큰 기반 인증
   - 자동 재연결 메커니즘
   - 이벤트 시퀀스 관리

2. **회원관리 페이지 접속 상태**
   - 실시간 온라인/오프라인/게임중 상태 표시
   - WebSocket을 통한 자동 업데이트
   - `/user-status/all` API 연동 구현

3. **로그 테이블 구조**
   - user_activity_logs (50만+ 레코드로 활발히 사용)
   - login_logs, game_play_logs 테이블 존재
   - member_change_logs, balance_sync_logs 등 다양한 로그 테이블

4. **대시보드 활동중인사용자 테이블**
   - ActiveUsersTable 컴포넌트 존재 (`/src/components/dashboard/tables/ActiveUsersTable.jsx`)
   - "접속자 현황" 섹션에 표시됨

#### ❌ **미구현 또는 개선 필요**
1. **데이터 영속성 부재**
   - UserStatusService가 100% 메모리에만 의존
   - 서버 재시작 시 모든 실시간 상태 정보 소실
   - members 테이블과 동기화 안 됨

2. **대시보드 ActiveUsersTable 하드코딩**
   - 12명의 고정된 샘플 데이터 사용 (user2001~user2012)
   - 2023년 5월 날짜의 오래된 데이터
   - `/user-status/all` API와 연동되지 않음
   - 실시간 업데이트 기능 없음

3. **마지막 게임 정보 표시**
   - 회원관리 페이지에서 게임 이름이 아닌 날짜/시간만 표시
   - userStatuses의 gameInfo 데이터 미활용

4. **게임 이력 영속성**
   - game_play_logs 테이블은 있지만 활용도 낮음 (398개 레코드)
   - 게임 시작/종료 시 DB 기록 미흡

---

## 🎯 구현 계획 (재수립)

### Phase 1: 데이터 영속성 구현 (우선순위: 최고)

#### 1.1 기존 테이블 활용 및 개선
```sql
-- members 테이블에 이미 있는 필드 확인 및 활용
-- connectionStatus, connectionDate, lastGame 필드 존재
-- 추가로 필요한 필드만 추가
ALTER TABLE members 
ADD COLUMN last_game_name VARCHAR(200) NULL COMMENT '마지막 플레이한 게임 이름',
ADD COLUMN online_status ENUM('offline','online','gaming') DEFAULT 'offline' COMMENT '실시간 접속 상태',
ADD COLUMN current_session_id VARCHAR(255) NULL COMMENT '현재 세션 ID',
ADD INDEX idx_online_status (online_status);

-- 기존 game_play_logs 테이블 활용 강화
ALTER TABLE game_play_logs
ADD COLUMN game_name VARCHAR(200) NULL COMMENT '게임 이름',
ADD COLUMN vendor VARCHAR(100) NULL COMMENT '게임 제공업체',
ADD INDEX idx_member_id (member_id);
```

#### 1.2 UserStatusService DB 연동
- 메모리 상태 변경 시 members 테이블 실시간 업데이트
- 로그인/로그아웃 시 connectionDate 업데이트
- 게임 시작/종료 시 lastGame, last_game_name 업데이트
- 서버 재시작 시 DB에서 온라인 상태 복원

#### 1.3 기존 로그 테이블 활용 강화
- user_activity_logs (이미 50만+ 레코드) 계속 활용
- login_logs에 세션 정보 추가 기록
- game_play_logs에 게임 이름 저장 추가

### Phase 2: 대시보드 ActiveUsersTable 실제 데이터 연동 (우선순위: 높음)

#### 2.1 ActiveUsersTable 컴포넌트 개선
**파일**: `/src/components/dashboard/tables/ActiveUsersTable.jsx`
```javascript
// 하드코딩된 데이터 제거
// const users = [...] // 삭제

// API 연동 추가
useEffect(() => {
  const fetchActiveUsers = async () => {
    const response = await apiService.userStatus.getAll();
    // 실제 활동중인 사용자만 필터링
    const activeUsers = response.data.users.filter(u => u.status !== 'offline');
    setUsers(activeUsers);
  };
  
  fetchActiveUsers();
  // Socket.IO 실시간 업데이트 연결
  socket.on('user:status-changed', fetchActiveUsers);
}, []);
```

#### 2.2 실시간 업데이트 구현
- Socket.IO 이벤트 리스너 추가
- 사용자 상태 변경 시 테이블 자동 업데이트
- 새로고침 버튼 실제 동작하도록 수정

### Phase 3: 회원관리 페이지 개선 (우선순위: 중간)

#### 3.1 마지막 게임 이름 표시
**파일**: `/src/pages/agent-management/MembersPage.jsx`
```javascript
// membersData.js 수정
lastGame: {
  header: '마지막 게임',
  accessor: 'lastGame',
  type: 'game', // datetime → game 타입으로 변경
  render: (value, row) => {
    const gameInfo = userStatuses[row.id]?.gameInfo;
    if (gameInfo?.gameName) {
      return `${gameInfo.gameName} (${formatTime(gameInfo.startTime)})`;
    }
    return row.last_game_name || '-';
  }
}
```

#### 3.2 접속 상태 시각화
- 온라인: 🟢 초록색 점
- 게임중: 🎮 파란색 아이콘  
- 오프라인: ⚫ 회색 점

### Phase 4: 고급 기능 (우선순위: 낮음)

#### 4.1 세션 관리 고도화
- 동시 접속 제한
- 비정상 종료 감지
- 세션 타임아웃 처리

#### 4.2 성능 최적화
- Redis 도입으로 메모리 캐싱
- 대량 동시 접속 최적화
- DB 쿼리 최적화

---

## ⚠️ 주의사항 및 위험 관리

### 1. 기존 시스템 영향 최소화
- **주의**: members 테이블에 이미 connectionStatus, connectionDate, lastGame 필드 존재
- **대응**: 기존 필드 활용, 최소한의 필드만 추가

### 2. 하드코딩 데이터 제거 시 영향
- **주의**: ActiveUsersTable의 샘플 데이터 제거 시 빈 화면 가능
- **대응**: API 연동 완료 후 단계적 전환

### 3. 실시간 성능
- **위험**: 대량 동시 접속 시 성능 저하
- **대응**: 초기에는 메모리+DB 병행, 추후 Redis 도입

### 4. 데이터 정합성
- **위험**: 메모리-DB 간 불일치
- **대응**: 트랜잭션 처리, 주기적 동기화

---

## 📋 구현 체크리스트

### 즉시 확인 필요
- [x] members 테이블 현재 스키마 확인 완료
- [x] ActiveUsersTable 컴포넌트 구조 확인 완료
- [x] 기존 로그 테이블들 사용 현황 확인 완료

### Phase 1 구현 항목 (데이터 영속성)
- [ ] members 테이블에 최소 필드만 추가
- [ ] UserStatusService DB 연동 구현
- [ ] 로그인/로그아웃 시 DB 업데이트
- [ ] 게임 시작/종료 시 DB 업데이트
- [ ] 서버 재시작 시 상태 복원 테스트

### Phase 2 구현 항목 (대시보드 실제 데이터)
- [ ] ActiveUsersTable 하드코딩 데이터 제거
- [ ] `/user-status/all` API 연동
- [ ] Socket.IO 실시간 업데이트 연결
- [ ] 새로고침 기능 실제 동작 구현

### Phase 3 구현 항목 (UI 개선)
- [ ] 마지막 게임 이름 표시
- [ ] 접속 상태 아이콘/색상 개선
- [ ] UI 반응성 테스트

### Phase 4 구현 항목 (고급 기능)
- [ ] Redis 캐싱 도입
- [ ] 세션 관리 강화
- [ ] 성능 모니터링

---

## 🚀 예상 일정

- **Phase 1**: 2일 (데이터 영속성 - 최우선)
- **Phase 2**: 1일 (대시보드 실제 데이터 연동)
- **Phase 3**: 1일 (UI 개선)
- **Phase 4**: 2-3일 (고급 기능 - 선택적)
- **테스트 및 안정화**: 1-2일

**총 예상 기간**: 7-9일

---

## 📝 핵심 발견사항 및 결론

### 재분석을 통한 핵심 발견

1. **대시보드 "활동중인사용자" 테이블은 존재하지만 하드코딩됨**
   - ActiveUsersTable 컴포넌트가 이미 구현되어 있음
   - 하지만 12명의 고정된 샘플 데이터만 표시
   - API는 준비되어 있으나 연동되지 않음

2. **DB 테이블 구조는 대부분 준비되어 있음**
   - members 테이블에 일부 추적 필드 이미 존재
   - user_activity_logs는 매우 활발히 사용 중 (50만+ 레코드)
   - game_play_logs 등 다양한 로그 테이블 존재

3. **가장 큰 문제는 데이터 영속성 부재**
   - UserStatusService가 100% 메모리 의존
   - 서버 재시작 시 모든 실시간 상태 소실
   - DB와 메모리 간 동기화 로직 없음

### 권장 구현 전략

1. **기존 구조 최대한 활용**
   - 이미 있는 테이블과 필드 활용
   - 최소한의 변경으로 최대 효과

2. **단계적 구현으로 리스크 최소화**
   - Phase 1: 데이터 영속성 (필수)
   - Phase 2: 대시보드 실제 데이터 (필수)
   - Phase 3: UI 개선 (권장)
   - Phase 4: 성능 최적화 (선택)

3. **실무 운영 고려사항**
   - 기존 기능 영향 없도록 점진적 적용
   - 하드코딩 데이터는 API 연동 완료 후 제거
   - 각 단계별 철저한 테스트

이 계획을 따르면 **최소한의 변경으로 안정적인 회원 추적 시스템**을 구축할 수 있습니다.